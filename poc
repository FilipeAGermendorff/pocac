-- AGUARDAR INICIALIZAÇÃO COMPLETA DO BOT
local function waitForBotReady(callback, attempts)
    attempts = attempts or 0
    if attempts > 30 then  -- 30 segundos máximo
        warn("[Ranking] Bot não inicializou completamente")
        return
    end
    
    -- Verificar se funções essenciais estão disponíveis
    if g_ui and g_ui.getRootWidget and onTextMessage and macro and UI and storage then
        local rootWidget = g_ui.getRootWidget()
        if rootWidget then
            print("[Ranking] Bot inicializado, carregando script...")
            callback()
            return
        end
    end
    
    -- Tentar novamente após 1 segundo
    schedule(1000, function()
        waitForBotReady(callback, attempts + 1)
    end)
end

-- SCRIPT PRINCIPAL (só executa quando bot estiver pronto)
local function initRankingScript()
    -- Seu script original aqui, mas com algumas melhorias
    
    -- Armazena últimas mensagens e rankings
    local lastRankingMessage = ""
    local lastRankingType = ""

    local rankingLists = {
        level = {}, ["magic level"] = {}, fist = {}, distance = {},
        sword = {}, axe = {}, club = {}, shield = {}, ["elo ranking"] = {},
        vocacao = {}
    }

    function string:trim()
        return self:match("^%s*(.-)%s*$") or ""
    end

    -- Função para aguardar UI específica estar pronta
    local function waitForRankingUI(callback, attempts)
        attempts = attempts or 0
        if attempts > 20 then
            warn("[Ranking] Ranking UI não carregou")
            return
        end
        
        local window = g_ui.getRootWidget():recursiveGetChildById("rankingsWindow")
        if window then
            local scroll = window:recursiveGetChildById("rankingScroll")
            if scroll then
                callback(window, scroll)
                return
            end
        end
        
        schedule(300, function()
            waitForRankingUI(callback, attempts + 1)
        end)
    end

    function selectRankingCategory(rankingKey)
        local window = g_ui.getRootWidget():recursiveGetChildById("rankingsWindow")
        if not window then return false end

        local tabBar = window:recursiveGetChildById("rankingTabBar")
        if not tabBar then return false end

        local tabNameMap = {
            ["magic level"] = "magic level",
            ["level"] = "level",
            ["fist"] = "fist",
            ["distance"] = "distance",
            ["sword"] = "sword",
            ["axe"] = "axe",
            ["club"] = "club",
            ["shield"] = "shield",
            ["elo ranking"] = "Elo Ranking",
            ["vocacao"] = "level"
        }

        local targetTabName = tabNameMap[rankingKey]
        if not targetTabName then return false end

        for i = 0, tabBar:getChildCount() - 1 do
            local tab = tabBar:getChildByIndex(i)
            if tab and tab:getText():lower() == targetTabName:lower() then
                tab:onClick()
                return true
            end
        end
        return false
    end

    function updateRankingFromUI(rankingKey)
        if not rankingKey then return end
        
        -- Primeiro verificar se ranking window está aberta
        local window = g_ui.getRootWidget():recursiveGetChildById("rankingsWindow")
        if not window then
            warn("[Ranking] Abra a janela de ranking primeiro!")
            return
        end
        
        selectRankingCategory(rankingKey)

        -- Aguardar UI estar pronta antes de extrair dados
        waitForRankingUI(function(window, scroll)
            local novaLista = {}
            
            -- Aguardar um pouco mais para garantir que a UI atualizou
            schedule(500, function()
                for i = 0, math.min(10, scroll:getChildCount() - 1) do
                    local item = scroll:getChildByIndex(i)
                    if item then
                        local name = ""

                        if rankingKey == "vocacao" then
                            local outfitBox = item:recursiveGetChildById("outfitBox")
                            if outfitBox and outfitBox.getTooltip and type(outfitBox.getTooltip) == "function" then
                                local tip = outfitBox:getTooltip()
                                if tip then
                                    local found = tip:match("Vocação:%s*(.-)%s*$")
                                    if found then
                                        name = found:trim()
                                    end
                                end
                            end
                        else
                            local nameLabel = item:getChildById("nameLabel")
                            if nameLabel and nameLabel.getText then
                                name = nameLabel:getText():trim()
                            end
                        end

                        table.insert(novaLista, name ~= "" and name or "?")
                    end
                end

                while #novaLista < 10 do
                    table.insert(novaLista, "")
                end

                rankingLists[rankingKey] = novaLista
                storage[rankingKey:gsub(" ", "")] = novaLista

                print("[Ranking] " .. rankingKey .. " atualizado:")
                for i, v in ipairs(novaLista) do
                    print(i .. ". " .. v)
                end
            end)
        end)
    end

    function parseRankingChallenge(text)
        local position = tonumber(text:match("#(%d+)") or text:match("em (%d+)") or text:match("(%d+)º lugar") or text:match("(%d+) lugar"))
        local lower = text:lower()

        local rankingType = nil
        if lower:find("vocacao") then rankingType = "vocacao"
        elseif lower:find("magic level") then rankingType = "magic level"
        elseif lower:find("fist") then rankingType = "fist"
        elseif lower:find("distance") then rankingType = "distance"
        elseif lower:find("sword") then rankingType = "sword"
        elseif lower:find("axe") then rankingType = "axe"
        elseif lower:find("club") then rankingType = "club"
        elseif lower:find("shield") then rankingType = "shield"
        elseif lower:find("elo") then rankingType = "elo ranking"
        elseif lower:find("level") then rankingType = "level" end

        return position, rankingType
    end

    function getRankingAnswer(position, rankingType)
        local list = storage[rankingType and rankingType:gsub(" ", "")] or {}
        if list and position and list[position] then
            return list[position]
        end
        return nil
    end

    onTextMessage(function(mode, text)
        if text:find("%[Desafio de Ranking%]") and text:find("!resposta") then
            lastRankingMessage = text
            local pos, tipo = parseRankingChallenge(text)
            lastRankingType = tipo

            updateRankingFromUI(tipo)
            schedule(1000, function() -- Delay maior para injeção externa
                local resposta = getRankingAnswer(pos, tipo)
                if resposta and resposta ~= "" then
                    say("!resposta " .. resposta)
                    print("[Ranking] Respondendo -> " .. resposta)
                    lastRankingMessage = ""
                else
                    warn("[Ranking] Ranking não encontrado: " .. (tipo or "nil") .. ", posição: " .. (pos or "nil"))
                end
            end)
        end

        if text:find("Resposta correta! Você foi teleportado") then
            if lastRankingType and lastRankingType ~= "" then
                print("[Ranking] Salvando automaticamente " .. lastRankingType .. " após acerto.")
                updateRankingFromUI(lastRankingType)
            end
        end
    end)

    macro(1000, function()
        if lastRankingMessage ~= "" then
            local pos, tipo = parseRankingChallenge(lastRankingMessage)
            lastRankingType = tipo

            updateRankingFromUI(tipo)
            schedule(1000, function()
                local resposta = getRankingAnswer(pos, tipo)
                if resposta and resposta ~= "" then
                    say("!resposta " .. resposta)
                    print("[Ranking] Respondendo Backup -> " .. resposta)
                    lastRankingMessage = ""
                end
            end)
        end
    end)

    UI.Button("Atualizar Ranking Atual", function()
        local window = g_ui.getRootWidget():recursiveGetChildById("rankingsWindow")
        if not window then warn("[BOT] rankingsWindow não encontrado.") return end

        local combo = window:recursiveGetChildById("skillComboBox")
        if not combo then warn("[BOT] skillComboBox não encontrado.") return end

        local selectedText = combo:getText() or ""
        if selectedText == "" then
            warn("[BOT] [Ranking] Opção inválida no ComboBox.")
            return
        end

        local normalized = selectedText:lower():gsub("%s+", "")
        local map = {
            ["level"] = "level",
            ["magiclevel"] = "magic level",
            ["fist"] = "fist",
            ["distance"] = "distance",
            ["sword"] = "sword",
            ["axe"] = "axe",
            ["club"] = "club",
            ["shield"] = "shield",
            ["eloranking"] = "elo ranking",
            ["lastdeaths"] = nil
        }

        local rankingKey = map[normalized]
        if rankingKey then
            updateRankingFromUI(rankingKey)
            print("[BOT] Ranking atualizado: " .. rankingKey)
        else
            warn("[BOT] Ranking '" .. selectedText .. "' não é compatível para atualização.")
        end
    end)

    UI.Button("Atualizar Vocação", function()
        updateRankingFromUI("vocacao")
        print("[BOT] Ranking de vocação atualizado via outfitBox.")
    end)
    
    print("[Ranking] Script carregado com sucesso!")
end

-- INICIAR SCRIPT APENAS QUANDO BOT ESTIVER PRONTO
print("[Ranking] Aguardando inicialização do bot...")
waitForBotReady(initRankingScript)
